<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backup on Zeneffy : journal de bord</title>
    <link>http://www.zeneffy.fr/tags/backup/</link>
    <description>Recent content in Backup on Zeneffy : journal de bord</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    
    
    
    <lastBuildDate>Mon, 19 Sep 2011 17:34:01 &#43;0000</lastBuildDate>
    <atom:link href="http://www.zeneffy.fr/tags/backup/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sauvegarder une base de donnée PostgreSQL chez Heroku</title>
      <link>http://www.zeneffy.fr/2011/09/sauvegarder-une-base-de-donnee-postgresql-chez-heroku/</link>
      <pubDate>Mon, 19 Sep 2011 17:34:01 &#43;0000</pubDate>
      
      <guid>http://www.zeneffy.fr/2011/09/sauvegarder-une-base-de-donnee-postgresql-chez-heroku/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.heroku.com&#34;&gt;Heroku&lt;/a&gt; permet de faire très simplement des sauvegardes des bases de données de production en utilisant le module &lt;a href=&#34;http://addons.heroku.com/pgbackups&#34;&gt;PGBackups&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Il faut d&amp;rsquo;abord installer le module soit via l&amp;rsquo;IHM web , soit via la commande ((dans le répertoire de l&amp;rsquo;application):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku addons:add pgbackups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puis simplement lancer une sauvegarde:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku pgbackups:capture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Une petite vérification s&amp;rsquo;impose:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku pgbackups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qui renvoie normalement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D   | Backup Time         | Size   | Database
-----+---------------------+--------+----------------
b001 | 2011/08/18 11:08.22 | 39.2KB | SHARED_DATABASE
b002 | 2011/09/19 10:24.04 | 40.2KB | SHARED_DATABASE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et finalement pour restaurer (avec b001 la base):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;heroku pgbackups:restore DATABASE b001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rappelez vous que la sauvegarde reste l&amp;rsquo;un des meilleurs moyens de sécuriser vos données.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gestion d&#39;urgence de l&#39;énergie</title>
      <link>http://www.zeneffy.fr/2009/03/gestion-durgence-de-lenergie/</link>
      <pubDate>Thu, 26 Mar 2009 10:41:00 &#43;0000</pubDate>
      
      <guid>http://www.zeneffy.fr/2009/03/gestion-durgence-de-lenergie/</guid>
      <description>&lt;p&gt;J&amp;rsquo;utilise un portable comme serveur, notamment pour diminuer consommation et bruit, mais cela a un autre avantage: la batterie du portable qui peut servir &amp;ldquo;d&amp;rsquo;onduleur&amp;rdquo; en cas de perte de courant.&lt;/p&gt;

&lt;p&gt;J&amp;rsquo;ai donc conçu un script simple pour gérer les pertes d&amp;rsquo;énergie, et prendre le temps de lancer un arrêt propre du serveur si l&amp;rsquo;alimentation n&amp;rsquo;est toujours pas rétablie.&lt;/p&gt;

&lt;p&gt;Dans /etc/acpi/events on crée un fichier ac_dc contenant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event=ac_adapter.*
action=/home/tifauve/scripts/acpi/battery/ac_dc.py %e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;et voici le script ac_dc.py appelé par le démon ACPI&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: utf-8 -*-

#
# Gère l&#39;état de la batterie
#

__author__ = &#39;Julien Raigneau&#39;
VERSION = &amp;quot;0.4&amp;quot;

import sys,os,logging
from time import strftime,sleep
from subprocess import Popen

lock_file = os.path.join(sys.path[0], &amp;quot;battery.lock&amp;quot;)
fork_path = os.path.join(sys.path[0], &amp;quot;ac_dc.py&amp;quot;)

def read_capacity():
    #récupere stats battery
    infos_batterie= open(&amp;quot;/proc/acpi/battery/BAT0/state&amp;quot;,&amp;quot;r&amp;quot;).readlines()
    capacite = int(infos_batterie[4].replace(&amp;quot;remaining capacity:&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;\n&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot; &amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;mAh&amp;quot;,&amp;quot;&amp;quot;))
    voltage = int(infos_batterie[5].replace(&amp;quot;present voltage:&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;\n&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot; &amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;mV&amp;quot;,&amp;quot;&amp;quot;))
    logging.info(&amp;quot;read_capacity: %s,%s&amp;quot; % (capacite,voltage))
    return capacite,voltage

def send_mail(sujet,corps):
    #envoi un mail
    msg = &amp;quot;sendEmail -s smtp.cegetel.net -t julien@raigneau.net -q -u \&amp;quot;%s\&amp;quot; -m \&amp;quot;%s\&amp;quot; -f admin@tifauve.net&amp;quot; % (sujet,corps)
    p = Popen(msg, shell=True)
    logging.info(&amp;quot;send_mail: Mail envoyé avec sujet=(%s)&amp;quot; % sujet)

def on_battery(capacite):
    #actions si sur battery
    while(os.path.isfile(lock_file)):
        capacite_encours,voltage = read_capacity()
        if capacite_encours &amp;lt;= capacite/2:
            logging.info(&amp;quot;on_battery: Capacité actuelle %s inférieur à la référence %s&amp;quot; % (capacite_encours,capacite))
            sujet = &amp;quot;[admin@champlain]Alerte critique: Extinction du serveur en cours&amp;quot;
            corps = &amp;quot;Toujours pas de rétablissement du courant le %s.\n/!\Extinction du serveur.\n\nCapacité restante: %s mAh\nVoltage: %s mV&amp;quot; % (strftime(&amp;quot;%d/%m/%Y à %H:%M:%S&amp;quot;),capacite_encours,voltage)
            send_mail(sujet,corps)
            os.remove(lock_file)
            logging.info(&amp;quot;on_battery: Extinction du serveur lancée&amp;quot;)
            p = Popen(&amp;quot;shutdown -P now&amp;quot;, shell=True)
        else:
            logging.info(&amp;quot;on_battery: Capacité actuelle %s&amp;quot; % capacite_encours)
            logging.info(&amp;quot;on_battery: En sommeil pendant 2min&amp;quot;)
            sleep(120)
    logging.info(&amp;quot;on_battery: plus de fichier de lock: sortie de la procédure&amp;quot;)

def on_dc():
    #actions si sur secteur
    logging.info(&amp;quot;on_dc: Remise sur secteur&amp;quot;)
    if os.path.isfile(lock_file):
        logging.info(&amp;quot;on_dc: suppression du fichier de lock&amp;quot;)
        os.remove(lock_file)


if __name__ == &#39;__main__&#39;:

    logFile = os.path.join(sys.path[0],&amp;quot;ac_dc.log&amp;quot;)
    logging.basicConfig(level=logging.DEBUG,
                    format=&#39;%(asctime)s %(levelname)s %(message)s&#39;,
                    filename=logFile)

    logging.info(&#39;main: == Démarrage des contrôles ac_dc ==&#39;)
    logging.info(&amp;quot;main: Valeur des arguments d&#39;entrée %s&amp;quot; % sys.argv)
    ac_dc_valeur = sys.argv[4]
    logging.info(&amp;quot;main: Valeur de l&#39;argument d&#39;entrée %s&amp;quot; % ac_dc_valeur)
    capacite,voltage = read_capacity()
    logging.info(&amp;quot;main: Etat de la batterie: %s / %s&amp;quot; % (capacite,voltage))

    if ac_dc_valeur == &amp;quot;00000000&amp;quot;:
        #si le lock existe déjà c&#39;est qu&#39;on est en mode &amp;quot;forké&amp;quot; sinon il faut forker
        if (os.path.isfile(lock_file)):
            logging.info(&amp;quot;main: le fichier de lock existe déjà =&amp;gt; nous sommes dans le fork&amp;quot;)
            corps = &amp;quot;Le courant a été coupé sur Champlain le %s.\nDébut de la procédure de sauvegarde.\n\nCapacité restante: %s mAh\nVoltage: %s mV&amp;quot; % (strftime(&amp;quot;%d/%m/%Y à %H:%M:%S&amp;quot;),capacite,voltage)
            sujet = &amp;quot;[admin@champlain]Alerte: perte d&#39;énergie sur CHAMPLAIN&amp;quot;
            send_mail(sujet,corps)
            on_battery(capacite)
        else:
                logging.info(&amp;quot;main: Création du fichier de lock&amp;quot;)
            file = open(lock_file,&amp;quot;w&amp;quot;)
            file.write(&amp;quot;%s&amp;quot; % capacite)
            file.close()
            logging.info(&amp;quot;main: Fork du process pour rendre la main au démon ACPI&amp;quot;)
            pid = Popen([fork_path, &amp;quot;00000000&amp;quot;, &amp;quot;00000000&amp;quot; ,&amp;quot;00000000&amp;quot;, &amp;quot;00000000&amp;quot;]).pid
            logging.info(&amp;quot;main: Fork effectué dans %s - sortie&amp;quot; % pid)

    else:
        corps = &amp;quot;Le courant a été rétabli sur Champlain le %s.\nFin de la procédure de sauvegarde.\n\nCapacité restante: %s mAh\nVoltage: %s mV&amp;quot; % (strftime(&amp;quot;%d/%m/%Y à %H:%M:%S&amp;quot;),capacite,voltage)
        sujet = &amp;quot;[admin@champlain]Fin d&#39;alerte: retour de l&#39;énergie sur CHAMPLAIN&amp;quot;
        send_mail(sujet,corps)
        on_dc()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SAISE - Sauvegarde Incrémentale Sécurisée</title>
      <link>http://www.zeneffy.fr/2008/09/saise-sauvegarde-incrementale-securisee/</link>
      <pubDate>Sat, 27 Sep 2008 09:23:21 &#43;0000</pubDate>
      
      <guid>http://www.zeneffy.fr/2008/09/saise-sauvegarde-incrementale-securisee/</guid>
      <description>&lt;p&gt;SAISE est le digne successeur d&amp;rsquo;&lt;a href=&#34;http://www.zeneffy.fr/2008/05/obiran-outil-de-backup-incremental-en-ruby/&#34;&gt;Obiran&lt;/a&gt; dont il reprend toutes les fonctionnalités, soit une sauvegarde incrémentale totale (chaque sauvegarde se suffit à elle même) distante via l&amp;rsquo;utilisation de la commande cp -al et de rsync. Les principes de base sont expliqués sur la page de présentation d&amp;rsquo;Obiran, lui-même disponible sur &lt;a href=&#34;http://code.google.com/p/obiran/&#34;&gt;http://code.google.com/p/obiran/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;SAISE apporte toutefois des différences importantes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SAISE est écrit en &lt;a href=&#34;http://www.python.org/&#34;&gt;Python&lt;/a&gt; (contrairement à Obiran, en Ruby)&lt;/li&gt;
&lt;li&gt;SAISE utilise la librairie &lt;a href=&#34;http://www.galago-project.org/downloads.php&#34;&gt;libnotify&lt;/a&gt; pour faire apparaître des notifications graphiques lors des backups (en option)&lt;/li&gt;
&lt;li&gt;SAISE a un système de log plus abouti&lt;/li&gt;
&lt;li&gt;Last but not least - SAISE permet de sécuriser les sauvegardes en cryptant à la volée les fichiers (à la demande de l&amp;rsquo;utilisateur)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Le système cryptage de SAISE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Pourquoi du cryptage ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Il est intéressant de sauvegarder ses données personnelles sur un serveur distant, pour des raisons évidentes de résilience. Toutefois, il peut être dangereux de laisser des données en clair (fichiers de configuration avec mots de passe, correspondance administrative ou financière, photos personnelles&amp;hellip;) sur un serveur dont on ne contrôle pas la sécurité.&lt;/p&gt;

&lt;p&gt;Aussi il m&amp;rsquo;a semblé important de réécrire Obiran en y intégrant une composante &amp;ldquo;sécurité des données&amp;rdquo;. Par conséquent, SAISE utilise la libraire python &lt;a href=&#34;http://www.freenet.org.nz/ezPyCrypto/&#34;&gt;ezPyCrypto&lt;/a&gt;, basée elle-même sur &lt;a href=&#34;http://www.amk.ca/python/code/crypto.html&#34;&gt;pyCrypto&lt;/a&gt;, qui permet de crypter/décrypter des fichiers facilement via des clés de grande taille et la plupart des algorithmes connus.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Comment cela fonctionne ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Via le fichier de configuration, l&amp;rsquo;utilisateur choisit les fichiers/répertoires à crypter et lors de la sauvegarde ces fichiers seront copiés sur le serveur distant cryptés et avec l&amp;rsquo;extension .crypted. Les fichiers en clair restent sur le disque dur de l&amp;rsquo;utilisateur et ne sont donc pas lisibles sur le serveur distant (des clés des 1024 bits ou 2048 bits seront très difficiles à casser&amp;hellip;).&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;algorithme de cryptage est donc très simple:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vérification de la présence d&amp;rsquo;une version non cryptée du fichier sur le répertoire distante =&amp;gt; suppression dans ce cas&lt;/li&gt;
&lt;li&gt;Vérification de la date de création du fichier crypté distant et comparaison avec la date du fichier en local =&amp;gt; Pas de traitement si le local n&amp;rsquo;est pas plus récent&lt;/li&gt;
&lt;li&gt;Cryptage du fichier et copie via scp sur le serveur distant.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A noter: Ce cryptage alourdit légèrement le traitement mais n&amp;rsquo;augmente pas trop la taille des fichiers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Versionnage&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SAISE v0.7: Suppression de la dépendance à paramiko&lt;/li&gt;
&lt;li&gt;SAISE v0.6.2: Consolidation de la gestion de configuration pour gérer les valeurs &amp;ldquo;n&amp;rsquo;importe quoi&amp;rdquo; + ajout d&amp;rsquo;un compteur d&amp;rsquo;erreur.&lt;/li&gt;
&lt;li&gt;SAISE v0.6.1: améliorations de la gestion des notifications (cas d&amp;rsquo;erreur) et de la gestion des fichiers externes (conf, log)&lt;/li&gt;
&lt;li&gt;SAISE v0.6: Ajout de notifications graphiques d&amp;rsquo;événements via libnotify (pynotify)&lt;/li&gt;
&lt;li&gt;SAISE v0.5: 1ere version fonctionnelle&lt;/li&gt;
&lt;li&gt;SAISE v0.4: cryptage en bonne voie / les fichiers unitaires fonctionnent, reste à finir la partie &amp;ldquo;gestion des répertoires cryptés&amp;rdquo;&lt;/li&gt;
&lt;li&gt;SAISE v0.3: début du travail sur la synchronisation des fichiers cryptés.&lt;/li&gt;
&lt;li&gt;SAISE v0.2: le rsync fonctionne (isofonctionnalités avec obiran)&lt;/li&gt;
&lt;li&gt;SAISE Premier commit / connexion en ssh possible&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Dépendances&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pour faire fonctionner SAISE, il vous faut:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SAISE&lt;/li&gt;
&lt;li&gt;rsync&lt;/li&gt;
&lt;li&gt;ssh&lt;/li&gt;
&lt;li&gt;libraires python: &lt;a href=&#34;http://roscidus.com/desktop/node/336&#34;&gt;pynotify&lt;/a&gt; &lt;a href=&#34;http://www.freenet.org.nz/ezPyCrypto/&#34;&gt;ezPyCrypto&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;License&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SAISE est sous &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;license apache v2.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Où trouver SAISE ?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ce projet est actuellement dans l&amp;rsquo;incubateur sur &lt;a href=&#34;https://code.google.com/p/tifauve-labs/&#34;&gt;Google Code&lt;/a&gt;, et les sources sont gérés via subversion sur &lt;a href=&#34;http://code.google.com/p/tifauve-labs/source/browse/trunk/SAISE&#34;&gt;http://code.google.com/p/tifauve-labs/source/browse/trunk/SAISE&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obiran - Outil de backup incrémental en Ruby</title>
      <link>http://www.zeneffy.fr/2008/05/obiran-outil-de-backup-incremental-en-ruby/</link>
      <pubDate>Mon, 12 May 2008 09:19:09 &#43;0000</pubDate>
      
      <guid>http://www.zeneffy.fr/2008/05/obiran-outil-de-backup-incremental-en-ruby/</guid>
      <description>&lt;p&gt;&lt;strong&gt;A propos&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Sauvegarder régulièrement les données est un réflexe à avoir car le monde numérique peut être impitoyable: imaginez toutes vos photos depuis 5 ans disparaissant suite à un disque dur cassé !&lt;/p&gt;

&lt;p&gt;Le mieux est d&amp;rsquo;automatiser cette tâche, aussi j&amp;rsquo;ai développé OBIRAN - Outil de Backup Incrémental en Ruby (&amp;lsquo;Obiran Kenobi, vous êtes notre seul espoir&amp;rsquo; (Princesse Leila, Starwars IV) ).&lt;/p&gt;

&lt;p&gt;Ce script en langage Ruby permet d&amp;rsquo;effectuer des sauvegardes incrémentales en utilisant rsync, ssh et cp.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rsync permet de synchroniser deux répertoires.&lt;/li&gt;
&lt;li&gt;ssh donne les accès à distance.&lt;/li&gt;
&lt;li&gt;cp -al est utilisé pour faire des copies de répertoires &lt;em&gt;Hard-Link en anglais&lt;/em&gt; sans perdre trop de place.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Principe&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incrémental ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ce script est très fortement inspiré des idées de synchronisation trouvées sur les pages suivantes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sanitarium.net/golug/rsync_backups.html&#34;&gt;Backups using rsync&lt;/a&gt; par Kevin Korb&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mikerubel.org/computers/rsync_snapshots/&#34;&gt;Easy Automated Snapshot-Style Backups with Linux and Rsync&lt;/a&gt; par Mike Rubel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le principe est de faire des sauvegardes incrémentales, c&amp;rsquo;est à dire ne sauvegarder que les différences d&amp;rsquo;un backup à l&amp;rsquo;autre. Ainsi la place consommée est bien moindre:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tifauve@einstein:~/backup/obiran/turing$ du -shc *
43G     20061016_170631
514M    20061016_204921
82M     20061017_205021
397M    20061018_200001
1,1G    20061018_202601
45G     total
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans l&amp;rsquo;exemple ci-dessous, la première sauvegarde prend 43Go mais l&amp;rsquo;espace occupé par les suivantes est bien inférieure. Cela permet de faire des sauvegardes fréquentes et complètes souvent.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Un peu de magie&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Toutefois, ce qui est reproché à l&amp;rsquo;incrémental en général est le risque de perdre la première sauvegarde sur laquel sont basées les autres. Que neni !&lt;/p&gt;

&lt;p&gt;En effet dans notre cas on utilise la commande cp -al qui permet de faire des &amp;lsquo;hard-link&amp;rsquo;, similaires aux symlinks (le célèbre ln -s). A l&amp;rsquo;inverse des symlinks qui crée un lien vers un fichier, le hard-link (ln -li pour les intimes) crée deux liens vers un seul et même fichier: supprimer un lien n&amp;rsquo;a aucune incidence sur l&amp;rsquo;autre lien et le fichier.&lt;/p&gt;

&lt;p&gt;La commande cp -al permet donc de dupliquer deux répertoires sans occuper de place supplémentaire. En reprenant l&amp;rsquo;exemple ci-dessus, on peut constater que les répertoires sont en fait presque de la même taille (le dernier est plus gros suite à des changements importants)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tifauve@einstein:~/backup/obiran/turing$ du -sh *
43G     20061016_170631
43G     20061016_204921
43G     20061017_205021
43G     20061018_200001
44G     20061018_202601
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si le répertoire &amp;lsquo;master&amp;rsquo; 20061016_170631 est supprimé, les autres répertoires conservent tout de même toutes les données.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Et Rsync dans tout ça ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Rsync permet de synchroniser les fichiers: c&amp;rsquo;est cette commande qui va gérer les différences entre deux fichiers d&amp;rsquo;un jour à l&amp;rsquo;autre. Si aucune différence (modification, ajout ou suppression) n&amp;rsquo;est trouvée alors le fichier n&amp;rsquo;est pas copié à travers le réseau&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;association de ces deux commandes permet de faire des sauvegardes rapidement et en occupant un minimum de place.&lt;/p&gt;

&lt;p&gt;Ce projet est entièrement géré via Google Code: &lt;a href=&#34;http://code.google.com/p/obiran/&#34;&gt;http://code.google.com/p/obiran/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>